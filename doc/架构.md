# FMLS 架构设计

基于 系统的自组织原理: (理想目标) 安装运行 FMLS 的各种设备,
在复杂多变的网络环境中, 应该能够自动发现别的设备, 自动建立连接关系,
自动进行网络性能优化, 而无需人工配置.

## 目录

- 1 节点类型
  - r0
  - r1
  - r2
- 2 实例类型
  - S
  - U
- 3 设备网络信息收集
- 4 公钥和证书
- 5 设备自动发现
  - 5.1 subtype
  - 5.2 TXT 记录
- 6 节点的连接关系
- 7 在线状态的跟踪
  - 7.1 邻居状态表
  - 7.2 保活消息
  - 7.3 在线状态推送
  - 7.4 状态变更通知
- 8 路由转发
- 9 本地应用接口
  - 9.1 邻居发现和设备信息获取
  - 9.2 命名通道
  - 9.3 透明通道
- 10 权限管理
  - 10.1 本机应用的权限管理
  - 10.2 本地防火墙
- 11 少数坏节点
- 12 双层通道
- 13 多信任域
- 14 低资源设备

## 1 节点类型

(node type) 根据设备在 FMLS 网络中的作用而进行的分类.

- `r0` **普通设备**

  这种设备在网络中的作用不太重要, 具有较多的计算/存储资源, 具有强大的操作系统.

  比如台式机, 笔记本, 手机, 平板, 电视盒子等. 操作系统有 GNU/Linux, Android,
  Windows 等.

- `r1` **网关设备**

  这种设备在网络中的作用比较重要, 具有较多的计算/存储资源,
  负责连接网络中的各个设备.

  比如路由器, 机架服务器等. 操作系统有 GNU/Linux, OpenWrt 等.

  网络中不建议有太多 `r1` 设备.

- `r2` **低资源设备**

  这种设备只有很少的计算/存储硬件资源, 很可能没有操作系统.

  比如单片机 (MCU).

`r0` / `r1` 设备在硬件资源 (计算/存储) 方面并没有显著的区别, 主要是软件
(操作系统) 和配置 (用户设置) 不同. `r0` 设备一般也能配置成 `r1` 设备运行, `r1`
设备一般也能配置成 `r0` 设备运行. 但有些 `r0` 设备, 因为不能连续运行 (比如手机,
为了省电会经常休眠), 或者操作系统的特性 (比如 Android 很难运行自定义的系统服务),
而不适合作为 `r1` 设备.

`r1` 设备一般需要 24x7 连续开机运行, 所以也要考虑功耗 (电费) 问题.
硬件资源不是特别少的低功耗设备 (比如路由器) 更适合作为 `r1` 设备.

`r2` 设备由于硬件资源太少, 并不能作为 `r0` / `r1` 设备. 用具体数值举例: 价格方面
(CNY), `r0` / `r1` 设备最便宜的不低于 100 元 (比如 Orange pi Zero 3 内存 1GB
版本), 而 `r2` 设备可能不到 1 元 (比如 ch32v003).

硬件资源方面: `r0` / `r1` 级别的设备, 比如红米 ax6s 路由器 (256MB 内存, 128MB
flash 存储, aarch64 CPU), 比如 Orange pi Zero 3 (1 ~ 4GB 内存, SD 存储卡 32GB
起步), 比如手机 (4 ~ 16GB 内存, 128GB ~ 1TB flash 存储), 比如笔记本/台式机 (8GB
内存起步, 256GB flash 存储起步). 而 `r2` 级别的设备, 比如 ch32v003 (2KB 内存,
16KB flash 存储, rv32ec CPU 单核 主频最高 48MHz). 可以看到,
硬件资源的差距是非常大的.

## 2 实例类型

(instance type) 在设备上安装 (配置) 的一个 FMLS 软件称为一个实例.

- `S` **系统实例** (`FMLSD-S`)

  以系统服务的方式运行, 一个系统中应该只有一个这种实例.

  操作系统有 GNU/Linux, OpenWrt, Windows 等.

- `U` **用户实例** (`FMLSD-U`)

  对于支持多用户的系统 (特别是允许多个用户同时登录的),
  每个登录的用户运行一个这种实例.

  操作系统有 GNU/Linux, Android, Windows 等.

在一个物理设备上, 可能同时运行多个 FMLS 实例, 比如有多个虚拟机的情况.

## 3 设备网络信息收集

FMLS 实例需要收集其所在设备的以下网络信息, 并保持更新:

- **系统时间** (UTC)

  网络中各设备的系统时间相差应该在 5 秒以内, 否则 FMLS 网络可能工作不正常
  (在线状态跟踪, 路由转发 等功能).

  即使设备之间的系统时间相差过大, FMLS 也应该尽量提供功能 (不依赖准确时间的).

  FMLS 主动跟踪邻居设备的系统时间.

- **网络接口** (可能多个) 及其 **状态** (开启/关闭)

  包括有线和无线网络接口, 以及软件虚拟的接口.

  并不向别的设备曝露接口名称, 而是使用接口编号 (ID, `u32`).
  尽量使用稳定的接口编号, 如果接口名称一致, 则对外提供的接口编号应该相同.

- 网络接口的 **速率**

  比如 10Mbps, 100Mbps, 1Gbps, 2.5Gbps, 10Gbps 等.

- 网络接口的 **IPv6 地址** (可能多个)

- 网络接口的 **IPv4 地址**

- wifi 连接的 **SSID**

## 4 公钥和证书

FMLS 实例在启动时, 如果发现没有公钥 (私钥), 就自动生成. 也就是实现首次运行时,
自动生成公钥.

FMLS 调用 OpenSSL 生成公钥 (私钥), 可用于 TLS (HTTPS), 使用椭圆曲线算法 (比如
ed25519).

FMLS 也可以生成 GPG 公钥 (私钥).

FMLS 实例使用公钥来标识设备的身份, 同一个设备上的系统实例和 (可能多个)
用户实例使用各自不同的公钥.

---

证书用于创建设备的 **信任域** (trust pool).

任何一个实例 (`r2` 除外) 都能作为 CA 来签发证书, 根据自己的公钥生成根证书.
具体使用哪个设备作为 CA, 取决于用户的选择.

具有相同根证书的各个设备, 属于同一个信任域. 一个设备要想加入信任域, 需要使用 CA
给这个设备的公钥签发证书, 这个设备拿到证书后, 才能加入信任域.
签发证书仍然通过调用 OpenSSL 实现.

一般情况下, FMLS 实例之间通过 HTTPS (HTTP/3 QUIC) 连接,
会同时验证两端的数字证书, 只有具有相同的根证书, 才能成功连接. 所以 FMLS
不仅使用公钥来标识设备的身份, 也在连接时验证其公钥.

---

通常只有属于同一个信任域的设备, 才能互相连接通信.

只有在签发证书 (一个设备加入信任域) 的时候, 才会开启临时通道,
不验证新设备的证书.

设备加入信任域, 需要用户人工操作, 这个不能自动进行.

**注意**: 请保护好每个实例的私钥, 防止泄漏. **私钥泄漏将使整个 FMLS
网络处于不安全状态**. 如果发现私钥泄漏, 请及时更换新的公钥/私钥 (重新生成).

## 5 设备自动发现

FMLS 使用 mDNS/DNS-SD 技术来进行设备的自动发现. 在 GNU/Linux 系统中, 一般使用
`Avahi` 软件来实现 mDNS/DNS-SD.

FMLS 实例 (`fmlsd`) 启动后, 在一个端口监听 (配置指定的端口, 或系统分配), 运行
HTTPS 服务器 (HTTP/3 QUIC), 等待来自别的设备的连接. 然后 FMLS 使用 avahi
发布这个端口, 比如:

```sh
> avahi-publish-service FMLSD-U-6166 _fmls_quic._udp 6166 r=r0 PK=NFtNNaY3w07Au7n3We77R1CTfgRePKaut+Dk1Mumxew RC=4y5PGYraU49KzXk0v5/agrim2sL4BqO25b4op8cdoq8 HOSTNAME=$(hostname)
```

其中 `_fmls_quic._udp` 是协议类型, `FMLSD-U-6166` 是服务名称, `6166` 是端口号.

同时 FMLS 周期调用 avahi 来发现别的设备:

```sh
> avahi-browse -artp
```

服务名称有:

- `FMLSD-S-port` 用于系统实例

- `FMLSD-U-port` 用于用户实例

- `FMLSD-CA-port` 专用于签发证书 (临时通道)

服务名称添加端口号 (`-port`), 因为一个系统上 mDNS/DNS-SD 服务名称不能重复.
而一个系统上可能同时存在多个实例, 所以添加端口号避免冲突.

注: OpenWrt 平台 (umdns) 可能不支持自定义服务名称. 并且有一些别的 BUG / 限制
(相比 Avahi).

### 5.1 subtype

用于缩小 mDNS/DNS-SD 的查询范围.

- `_r1._sub._fmls_quic._udp`

  用于 `r1` 设备.

- `_ca._sub._fmls_quic._udp`

  用于证书签发 (临时通道).

### 5.2 TXT 记录

mDNS/DNS-SD 提供的文本键值对, 可用于传递更多信息.

- `r` 表示节点类型

  `r=r0` 表示 `r0` 设备, `r=r1` 表示 `r1` 设备, r2 设备一般不会使用 mDNS/DNS-SD
  发布服务.

- `PK` 表示自己的公钥

  格式: base64(sha256(K))

  由于公钥可能很长, 此处使用 sha256 进行压缩. K 表示公钥的完整文本表示.

- `RC` 表示根证书的公钥 (用于区分信任域)

  格式: base64(sha256(K))

- `HOSTNAME` 表示主机名

  由于 OpenWrt 系统 umdns 的 BUG, 需要主机名才能获取 IP 地址.

- `r1` 提示 r1 设备的用途

  `r1=r2` 表示专用于 r2 设备连接的 r1 设备, 普通 r0 设备应该尽量避免连接此 r1
  设备 (优先连接别的 r1 设备).

## 6 节点的连接关系

- `r1` 设备尝试与信任域中的所有 `r1` 设备主动建立连接 (HTTP/3),
  包括自己直接发现的, 以及通过别的 `r1` 间接发现的.

  如果目标 `r1` 无法通过 IP 网络直连, 则不建立连接.

  由于任意两个 `r1` 之间都建立双向连接, 因此不建议信任域中有太多 `r1` 设备.

- `r1` 设备不会主动与 `r0` 设备建立连接. 一般情况, `r1` 设备也不主动连接 `r2`
  设备, 但专门配置需要主动连接 `r2` 的除外.

- `r2` 设备只主动与一个 `r1` 设备建立连接. 由于 `r2` 设备硬件资源很少,
  连接协议不一定是 HTTP, 可能是更简单的协议.

  对于某些具有特殊要求的 `r2` 设备, 可以同时与多个 `r1` 设备主动连接.

- 如果发现了 `r1` 设备, 则 `r0` 设备随机选择一个主动建立连接.
  如果连接失败就换一个 `r1` 进行尝试.

  同时, `r0` 设备随机选择 2 个 `r0` 邻居 (直接发现) 主动建立连接.

  `r0` 实例启动时, 每秒进行一次设备发现扫描, 如果连续 3 次都没发现 `r1` 设备,
  则认为 `r1` 不存在.

- 如果没有发现 `r1` 设备, 则 `r0` 与其所有 `r0` 邻居主动建立连接.

除了 `r2` 设备, 当存在多个设备时, 每个设备都同时与多个设备直接连接. 这样可以避免
(FMLS 连接的) 单点故障.

## 7 在线状态的跟踪

FMLS 网络跟踪每个节点的在线状态. FMLS 实例启动时, 每秒进行一次设备发现扫描
(mDNS/DNS-SD). 由于 mDNS 使用多播 (广播) 来发送查询数据, 大量节点频繁进行
mDNS/DNS-SD 查询可能影响网络性能. 当一个节点与任意别的节点建立连接之后,
设备发现扫描频率降低为每 3 秒一次. 当一个节点与另一个 r1 节点建立连接之后,
设备发现扫描频率降低为每 5 秒一次.

`r1` 设备跟踪信任域中的所有 `r1` 节点的在线状态, 同时跟踪自己下属的
(主动连接自己的) `r0`, `r2` 设备的在线状态.

`r0` 设备跟踪自己直接发现以及直接连接的设备的在线状态, 以及自己 `r1`
设备下属的所有 `r0` 设备的在线状态.

`r2` 设备只跟踪其连接的 `r1` 设备的在线状态.

对于不直接跟踪的节点, 可以向 `r1` 查询某个节点的在线状态.

### 7.1 邻居状态表

每个 FMLS 实例维护一个邻居状态表, 其中的状态有:

- `0` **未发现**

  相当于这条数据在表中不存在.

- `1` **本机**

  这条数据表示自己, 或者和自己在同一个系统上的实例 (系统实例, 或用户实例).

  不应该和本机实例建立网络连接 (HTTP/3), 应该使用系统内部的接口.

- `2` **未知信任域**

  通过设备自动发现 (mDNS/DNS-SD) 发现了这个设备,
  但其根证书公钥不属于自己已经加入的信任域.

  这种设备应该忽略.

- `3` **已发现**

  通过设备自动发现 (mDNS/DNS-SD) 发现了这个设备,
  且其根证书公钥属于自己已经加入的信任域.

  但并未实际验证这个设备的身份 (比如其公钥和证书是否正确).

- `4` **已验证**

  没有与这个设备建立连接, 但这个设备的身份 (公钥/证书) 已经验证.

  比如一个 `r0` 设备已经与 `r1` 建立了连接, 那么别的 `r0` 从 `r1` 得到通知,
  将这个 `r0` 标记为 `已验证`.

- `5` **已连接**

  已经成功与这个设备 (主动/被动) 建立了连接 (HTTP/3). 这个设备的身份 (公钥/证书)
  没有问题.

- `-1` **验证失败**

  这个设备的公钥或证书不正确, 可能是恶意设备. 在很长时间内,
  拒绝与这个设备的连接.

如果没有更新, 表中的数据在 10 秒之后认为过期 (`0` 未发现).

### 7.2 保活消息

主动发起连接的设备, 每秒发送一次保活消息 (`ping`), 对方收到后回复保活响应
(`pong`).

如果连续 3 秒未收到对方的消息, 则认为设备离线.

### 7.3 在线状态推送

`r1` 设备每 3 秒推送一次在线状态表.

- `r1` 设备向信任域中的所有别的 `r1` 推送所有 `r1` 的在线状态.

- `r1` 设备向其下属的 `r0` 推送所有 `r1`, 以及其下属的所有 `r0` 的在线状态.

对于 `r2` 设备的在线状态, `r1` 只在主动连接主动要求的时候才发送.

### 7.4 状态变更通知

当一个实例主动检测到别的设备的在线状态变更时, 向所有连接的设备发送状态变更通知.

当收到别的设备发送的状态变更通知时, 根据情况进行转发.
本设备直接检测到的在线状态, 优先于别的设备的离线状态. 如果别的设备通知,
某个设备离线, 但是本设备认为其在线, 则忽略该通知.

进行转发时, 标记来源 (最初发出该通知的设备), 以及时间. 对于超过 10 秒的过时消息,
直接忽略不处理. 同时, 对于本设备发出 (直接发出, 或转发) 的通知消息,
保存在缓存表中, 保存 20 秒. 如果收到缓存表中已经记录的消息, 直接忽略不处理.
这是为了避免循环转发通知消息.

`r1` 设备向所有连接的设备转发 `r1` 设备的状态变更通知. `r1` 设备向其下属的所有
`r0` 设备转发其下属 `r0` 设备的状态变更通知. `r0`
设备向所有连接的设备转发状态变更通知.

## 8 路由转发

当需要连接目标设备发送消息的时候, 首先获取目标设备的 IP 地址, 并尝试直接连接
(HTTP/3). 直连失败时, 才通过 `r1` 设备进行路由转发.

连接设备发送消息的大致过程如下:

1. 首先, 通过设备发现 (直接/间接), 或用户手动输入, 获取目标设备的公钥.

2. 根据公钥, 获取目标设备的在线状态. 如果本设备能直接获取目标设备的在线状态,
   就使用自己的, 否则向 `r1` 设备发出在线状态查询.

   如果 `r1` 设备无法直接获取目标设备的在线状态, 向所有别的 `r1`
   设备发送查询请求.

3. 如果目标设备不在线, 则连接失败, 返回错误信息.

   如果目标设备在线, 上述过程也同时获取了目标设备的 IP 地址, 对所有 IP
   地址进行直接连接尝试 (按一定优先级顺序).

4. 如果直接连接成功, 则进行发送消息.

   如果直连失败, 请求 `r1` 设备进行路由转发.

5. 如果 `r1` 设备能直连目标设备, 则进行连接, 完成路由转发.
   此时整个连接的路由转发只经过 1 个 `r1` 设备.

   如果不能连接, 则尝试直接连接能直连目标设备的 `r1` 设备. 如果可以直连,
   则整个连接的路由转发经过 2 个 `r1` 设备.

   如果还不行, 再进一步增加中继 `r1` 设备. 在上面获取目标设备在线状态的同时,
   `r1` 设备其实也同时获取了到达目标设备的路由路线.

FMLS 经过 `r1` 的路由转发, 由于提前计算了整个路由路径, 可以避免路由环路.

在大部分不太复杂的网络环境中, 直接连接目标设备的 IP 地址,
在大部分情况下都是可以成功的. 需要经过多个 `r1` 设备的复杂路由转发,
实际用到的时候很少.

## 9 本地应用接口

(local api) FMLS 实例 (`fmlsd`) 给本地应用提供的接口. 本地应用可通过此接口使用
FMLS 的功能, 通过 FMLS 网络进行连接通信.

- 优先使用 `UNIX socket`

  适用的操作系统有 GNU/Linux, Android, OpenWrt 等.

  比如在 GNU/Linux 平台, 系统实例将使用 socket 地址:

  `/run/fmls/fmlsd.s`

  用户实例将使用 `$XDG_RUNTIME_DIR/fmls/fmlsd.s`, 比如:

  `/run/user/1000/fmls/fmlsd.s`

- 在不支持 `UNIX socket` 的平台, 使用本地 TCP socket

  适用的操作系统有 Windows 等.

  也就是只在本地环回地址 (`::1`) 监听, 这将只允许本地应用连接.

  端口号以及验证所需的共享密钥, 会写入固定的本地文件中.
  只有有权限读取此文件的应用, 才能成功连接.

- 平台专用的应用间通信方式

  比如 Android 系统使用的 `AIDL` (`binder`) 接口.

  目前只用于 Android 系统.

通过 socket 发送/接收单行文本消息, 详见 [JSON 接口](./json_api.md).

同一个系统上的系统实例和用户实例之间, 也通过本地应用接口进行连接.
用户实例作为系统实例的一个应用.

### 9.1 邻居发现和设备信息获取

本地应用可通过 FMLS 提供的接口, 查询邻居节点的列表, 以及邻居设备的信息.

邻居节点包括整个 FMLS 信任域中的 `r0`, `r1` 节点. 邻居信息包括公钥, 在线状态, IP
地址, 自定义节点信息等.

自定义节点信息包括:

- (`fmls.name`) 名称 (utf-8 字符串)

- (`fmls.desc`) 描述 (utf-8 字符串)

- 扩展信息 (任意 键值对 字符串)

  以 `fmls.` 开头的键名, 为 FMLS 所保留, 别的应用不应使用.
  某个本地应用专用的键名, 建议以 `APP/` 的格式开头, 其中 `APP`
  是应用选择的专用标识.

### 9.2 命名通道

(named channel) 以单行 utf-8 字符串作为名称的通道, 应用可在 FMLS
实例注册和监听命名通道 (订阅/发布 机制).

应用可直接向目标设备 (公钥) 的某个命名通道 (名称) 发送单个消息. FMLS
会自动完成整个连接目标设备和消息发送工作, 并报告执行结果 (发送成功/失败).

以 `fmls.` 开头的命名通道, 为 FMLS 所保留, 别的应用不应使用.
某个本地应用专用的命名通道, 建议以 `APP/` 的格式开头, 其中 `APP`
是应用选择的专用标识.

以 `.` 开头的命名通道, 只用于本机, 禁止通过网络接收消息. 以 `.fmls.`
开头的命名通道, 为 FMLS 所保留, 别的应用不应使用.

### 9.3 透明通道

(transparent channel) 透明通道类似于 TCP 连接, 应用可发送任何数据.
透明通道没有名称, 使用 ID (`u32`) 表示.

透明通道在应用需要时, 发起连接, 然后 FMLS 会建立一个端到端通道 (可能经过 `r1`
路由转发). 使用完毕后需要关闭通道.

## 10 权限管理

### 10.1 本机应用的权限管理

控制各个本地应用对 fmls 的访问.

默认情况下, 以相同用户 (fmlsd) 运行的应用, 对 fmls 具有完全控制权限.

fmls 支持以下情况的权限管理:

- Android 应用: 由于 Android 系统各应用相互隔离, fmls 可识别不同的应用,
  并对访问进行限制. 用户可对每个应用单独授权.

- flatpak: 由于 flatpak 应用默认运行在沙箱中, 对本地资源进行有限的访问, fmls
  可识别不同的 flatpak 应用, 并进行权限管理 (fmls-dbusb).

- 操作系统支持的多用户: 如果一个应用以另一个用户运行, 则 fmls 可以识别,
  并进行权限管理.

权限管理的内容包括 (但不限于):

- 能够使用的 fmls 功能: 获取本机网络信息, 获取邻居节点信息, 自定义节点信息,
  命名通道, 透明通道.

- 能够读取/设置的自定义节点信息的键值.

- 能够订阅/发布的命名通道名称.

- 能够访问的远程节点.

### 10.2 本地防火墙

fmls 防火墙功能在本地设置, 用于限制本机和邻居节点的交互.

fmls 防火墙的功能包括 (但不限于):

- 允许访问的信任域.

- 允许访问的 r1 节点 (禁用的 r1 节点列表).

- 允许访问的邻居节点.

- 允许签发证书 (fmls ca server).

- 允许的命名通道.

- 路由转发.

fmls 防火墙规则参数:

- 源信任域 (公钥)

- 目的信任域 (公钥)

- 源主机 (公钥)

- 目的主机 (公钥)

- 功能: 邻居发现, 节点信息, 透明通道, 命名通道, 路由转发.

- 命名通道名称.

## 11 少数坏节点

(bad node) 在信任域中, 可能会出现少数 "坏节点", 可能会破坏网络的安全信任关系.
此处以私钥泄漏为例, 给出发现坏节点后的处理方式.

- 根证书 (CA) 私钥泄漏: 这个是严重事件, 将彻底破坏网络安全.

  处理方式: 重新建立信任域 (人工处理). 具体包括重新选择 CA 设备, 生成新的根证书
  (公钥), 所有设备加入新的信任域.

- 普通节点 (非 CA) 私钥泄漏: 这个相对不严重.

  处理方式: 更新根证书 (自动处理). 由 CA 发起, 生成新的公钥和根证书,
  给所有设备重新签发证书 (坏节点除外), 推送给所有设备新的证书,
  各设备自动加入新的信任域.

对于小规模局域网, 这种对于所有节点的操作是可以接受的.

也就是说, FMLS 不使用证书撤销 (OCSP, CRL). 因为证书撤销实现起来复杂, 且不可靠.

## 12 双层通道

(double layer channel) 各节点 (`r0`, `r1`) 之间, 优先尝试直连通信. 即通过 FMLS
网络获取目标节点的 IP 地址之后, 会首先直接连接 (HTTP/3 QUIC).

但是, 在某些比较复杂的网络环境中, 无法直连通信, 此时会通过 `r1` 进行路由转发.
但是, 由于上述 "坏节点" 问题, 如果一个 `r1` 节点成为坏节点,
可能会导致所有通过路由转发的流量不再安全.

经过 `r1` 路由转发的端到端通道, 类似一个 TCP 连接. 因此,
通信的两端可以在此通道之上, 运行基于 TCP 的加密通信协议, 比如:

- `TLS` (HTTPS HTTP/2)

  优点是可以复用两端现有的数字证书.

- `SSH`

  这种方式可能需要单独的 SSH 密钥.

此时, 即使中间 `r1` 节点是不可信的, 端到端通信仍然是安全的.

## 13 多信任域

一个节点可以同时属于多个信任域 (拥有多个数字证书).

如果是 `r1` 节点, 可以进行信任域之间的路由转发.

## 14 低资源设备

低资源设备 (`r2`) 只有很少的计算/存储硬件资源, 很可能没有操作系统, 比如单片机
(MCU).

由于硬件资源的限制, `r2` 很可能无法运行完整的 FMLS 软件及协议, 甚至可能无法加密
(没有能力处理公钥加密和对称加密, 如 AES).

`r2` 设备的连接方式也可能不是 IP 网络 (比如有线以太网), 比如 USB, UART (串口)
等.

此时, 有一个专用的网关设备 (`r1`) 负责 `r2` 设备接入 FMLS 网络. 这个 `r1` 代理对
`r2` 的访问, `r2` 设备与别的设备发送消息, 都要通过 `r1` 转发. 这个 `r1`
也可以配置权限管理相关功能, 类似防火墙, 控制别的设备对 `r2` 的访问.

FMLS 假设, 这个 `r1` 及其与 `r2` 的物理链路 (建议使用有线连接), 都是安全可信的.
因为 `r1` 与 `r2` 的直连链路, 很可能是明文传输, 此时需要保证物理安全,
即防止攻击者物理接触并入侵这段传输线路. 建议 `r1` 设备部署在 `r2` 附近,
缩短之间的线路长度, 减小安全风险.

如果 `r1` 设备, 或者 `r1` 连接 `r2` 的线路, 不再安全, 则对应的 `r2`
设备也不安全.

---

TODO
